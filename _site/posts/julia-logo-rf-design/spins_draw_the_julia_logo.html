<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Carlos Castillo-Passi">
<meta name="dcterms.date" content="2025-11-03">
<meta name="description" content="How the physics of MRI can be used to draw with spins and why this is useful.">

<title>I Drew the Julia Logo Using an MRI Machine ‚Äì Bloch Hole</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-170ae15f2792898595abfc1418f9b94b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="I Drew the Julia Logo Using an MRI Machine ‚Äì Bloch Hole">
<meta property="og:description" content="How the physics of MRI can be used to draw with spins and why this is useful.">
<meta property="og:image" content="https://cncastillo.github.io/BlochHole/posts/julia-logo-rf-design/figures/rf_2dexcitation_logo.gif">
<meta property="og:site_name" content="Bloch Hole">
<meta name="twitter:title" content="I Drew the Julia Logo Using an MRI Machine ‚Äì Bloch Hole">
<meta name="twitter:description" content="How the physics of MRI can be used to draw with spins and why this is useful.">
<meta name="twitter:image" content="https://cncastillo.github.io/BlochHole/posts/julia-logo-rf-design/figures/rf_2dexcitation_logo.gif">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Bloch Hole</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/cncastillo"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://x.com/Carlos_CP92"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">I Drew the Julia Logo Using an MRI Machine</h1>
                  <div>
        <div class="description">
          How the physics of MRI can be used to draw with spins and why this is useful.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Bloch simulations</div>
                <div class="quarto-category">MRI physics</div>
                <div class="quarto-category">Automatic differentiation</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Carlos Castillo-Passi </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 3, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#magnetic-resonance" id="toc-magnetic-resonance" class="nav-link active" data-scroll-target="#magnetic-resonance">Magnetic resonance</a></li>
  <li><a href="#slice-selection" id="toc-slice-selection" class="nav-link" data-scroll-target="#slice-selection">Slice selection</a></li>
  <li><a href="#d-excitation" id="toc-d-excitation" class="nav-link" data-scroll-target="#d-excitation">2D excitation</a></li>
  <li><a href="#designing-arbitrary-2d-excitation-pulses" id="toc-designing-arbitrary-2d-excitation-pulses" class="nav-link" data-scroll-target="#designing-arbitrary-2d-excitation-pulses">Designing arbitrary 2D excitation pulses</a></li>
  <li><a href="#conclusions" id="toc-conclusions" class="nav-link" data-scroll-target="#conclusions">Conclusions</a></li>
  <li><a href="#acknowledgemnts" id="toc-acknowledgemnts" class="nav-link" data-scroll-target="#acknowledgemnts">Acknowledgemnts</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="magnetic-resonance" class="level1">
<h1>Magnetic resonance</h1>
<p>It all starts with <strong>resonance</strong>. What does that even mean? Long ago, physicist Joseph Larmor discovered that the frequency <span class="math inline">\(f\)</span> at which spins precess depends on the magnetic field strength <span class="math inline">\(B\)</span>: <span class="math display">\[
f = \frac{\gamma}{2\pi} B\quad\text{(Larmor's equation).}
\]</span> The constant <span class="math inline">\(\gamma/2\pi\)</span> is known as the gyromagnetic ratio. For hydrogen (protons), which MRI typically detects, <span class="math inline">\(\gamma/2\pi = 42.58\,\mathrm{MHz/T}\)</span>. In a typical MRI scanner with a field strength of <span class="math inline">\(3\mathrm{T}\)</span>, the Larmor (precession) frequency for hydrogen protons is about <span class="math inline">\(127.74\ \mathrm{MHz}\)</span>, which lies in the FM radio band!</p>
<p>If we apply a radio-frequency (RF) pulse at that frequency ‚Äî the RF field commonly denoted <span class="math inline">\(B_1\)</span> in MRI ‚Äî it will tip the spins away from alignment with the main magnetic field, <span class="math inline">\(B_0\)</span> (the z-direction). <strong>This is analogous to pushing a child on a swing</strong>: if the pushes are applied at the correct intervals, the swing‚Äôs amplitude increases. Oh! So that is resonance!</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/rf_excitation_onespin.gif" class="img-fluid figure-img"></p>
<figcaption>Fig. 1: The <span class="math inline">\(B_1\)</span> pulse (blue) tips the spins‚Äô magnetization at the precession (Larmor) frequency. As the magnetization is tipped, it becomes measurable (we measure the xy-component with MRI), as shown by the color change to yellow.</figcaption>
</figure>
</div>
<p>Because visualizing spins and RF fields oscillating at the Larmor frequency all the time is tedious, we work in the ‚Äúrotating frame.‚Äù Imagine rotating at the same rate as the spins precess so that the fast Larmor rotation disappears in this moving frame. The RF field then appears as a slowly varying complex envelope (amplitude and phase) that actually controls the spins. This simplifies the picture: we need only think about the RF envelope, not the high‚Äëfrequency carrier. We will use this rotating frame from now on.</p>
</section>
<section id="slice-selection" class="level1">
<h1>Slice selection</h1>
<p>To get a 2D picture from a 3D object we first pick a thin slice (<strong>like cutting a cheese slice</strong>). MRI can do this because the scanner can add a magnetic-field gradient <span class="math inline">\(G_z\)</span> along the <span class="math inline">\(z\)</span> axis. That gradient makes the Larmor frequency vary with position: spins at different <span class="math inline">\(z\)</span> positions precess at different frequencies. In other words, <strong>frequency becomes a spatial label</strong>.</p>
<p>If we transmit an RF pulse whose spectrum covers only a small band of frequencies, only spins whose Larmor frequency lies in that band will be tipped ‚Äî so only that z-range (the slice) is excited. Using the Fourier-transform, a narrow, rectangular passband in frequency corresponds to a long <strong>sinc pulse</strong> in time. So, to excite a slice you play a sinc‚Äëshaped RF envelope while the <span class="math inline">\(G_z\)</span> gradient is on. The width of the slice is set by the gradient strength and the bandwidth of the RF pulse.</p>
<p>Because the gradient is on while the RF is applied, spins at different z positions accumulate different phases. To undo that extra phase (so the excited spins are coherent within the slice) we apply a small ‚Äúrefocusing‚Äù or rephasing gradient lobe after the RF. That final lobe re-centers the phase across the slice and leaves us with a clean, selectively excited 2D slab ready for further manipulation or imaging.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/rf_excitation.gif" class="img-fluid figure-img"></p>
<figcaption>Fig. 2: The scanner selects a thin slice by briefly applying a magnetic-field gradient and a shaped radio‚Äëfrequency (RF) pulse. The RF pulse only tips spins inside the slice (shown in yellow); spins outside remain aligned with the main field and are not detected.</figcaption>
</figure>
</div>
<p>If you‚Äôve ever had an MRI scan, you‚Äôve experienced slice selection. This standard and widely used technique lets MRI acquire 2D slices.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/brain_slice_selection.png" class="img-fluid figure-img"></p>
<figcaption>Fig. 3: Example of slice selection on an MRI console. The highlighted box shows the planned cross‚Äësection (a horizontal slice) through the middle of the brain. The scanner displays this slice during planning and then shows the acquired image for that slice in the image panel. <a href="https://mrimaster.com/planning/">Source</a></figcaption>
</figure>
</div>
</section>
<section id="d-excitation" class="level1">
<h1>2D excitation</h1>
<p>So far we used a gradient along z to select a thin slice in the z-direction (1D pattern). Can we excite an arbitrary 2D pattern? Yes.</p>
<p>By playing time‚Äëvarying gradients in two orthogonal directions (x and y) while transmitting a shaped RF waveform, the RF tips spins at specific x‚Äìy locations. A simple picture: the gradients change which position is ‚Äúin tune‚Äù with the RF, and the RF turns spins on at those positions ‚Äî like steering a paintbrush while painting.</p>
<p>Under the common ‚Äúsmall‚Äëtip‚Äëangle‚Äù approximation, the excited transverse magnetization pattern is (approximately) the 2D Fourier transform of the RF waveform sampled along the path the gradients trace through ‚Äúexcitation k‚Äëspace.‚Äù Excitation k‚Äëspace is the 2D Fourier domain: each k‚Äëspace coordinate corresponds to a spatial frequency. By choosing the k‚Äëspace trajectory (for example, spiral) and designing the RF accordingly, you can synthesize many useful 2D patterns; the trajectory‚Äôs extent and sampling density set the achievable field‚Äëof‚Äëview and resolution.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/rf_2dexcitation.gif" class="img-fluid figure-img"></p>
<figcaption>Fig. 4: A ‚Äúpencil‚Äëbeam‚Äù excitation. A spiral gradient steers which location is in resonance while a jinc‚Äëshaped RF pulse tips spins at those locations, producing a narrow cylindrical region of excited signal (like a pencil).</figcaption>
</figure>
</div>
<p>A ‚Äúpencil‚Äëbeam‚Äù excitation creates a narrow, cylindrical region of magnetization. By positioning this small beam over the liver you get a continuous signal that changes as the patient breathes: the liver moves with respiration, and that motion modifies the measured signal. This motion signal is used as a respiratory trace to accept data only during a chosen breathing phase (for example, end‚Äëexpiration) and to reject data acquired at other times, <strong>reducing motion artifacts in cardiac MRI</strong>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/cardiac_mri_2d_excitation.png" class="img-fluid figure-img"></p>
<figcaption>Fig. 5: Respiratory trace from a pencil‚Äëbeam excitation. The beam monitors motion along the head‚Äìfoot (z) axis, the blue band is the acceptance window around end‚Äëexpiration. <a href="https://i-mri.org/ViewImage.php?Type=F&amp;aid=727808&amp;id=F7&amp;afn=1040_IMRI_25_4_209&amp;fn=imri-25-209-g007_1040IMRI">Source</a></figcaption>
</figure>
</div>
</section>
<section id="designing-arbitrary-2d-excitation-pulses" class="level1">
<h1>Designing arbitrary 2D excitation pulses</h1>
<p>Now that we know 2D excitation is possible and have an intuition for how it works, how do we design an RF pulse that produces a specific 2D pattern?</p>
<p>We pose this as an <strong>inverse problem</strong> ‚Äî that is, we look for the input (the RF pulse) that produces a desired output (the magnetization pattern). Or the cause of a given effect. The <strong>forward model</strong> <span class="math inline">\(\mathbf{A}(\mathbf{x})\)</span> predicts the transverse magnetization produced when we play an RF waveform <span class="math inline">\(\mathbf{x}\)</span> (and the chosen gradient waveforms). If our desired magnetization pattern is <span class="math inline">\(\mathbf{b}\)</span>, we can formulate the design as a <strong>least‚Äësquares optimization problem</strong>:</p>
<p><span class="math display">\[
\min_{\mathbf{x}} \Vert \mathbf{A}(\mathbf{x}) - \mathbf{b} \Vert_2^2.
\]</span></p>
<p>Here the forward model <span class="math inline">\(\mathrm{\mathbf{A}}(\mathbf{x})\)</span> is implemented by a <strong>physics simulation</strong>: we numerically solve the Bloch equations for a given RF waveform and gradient trajectory to predict the resulting transverse magnetization. Rather than reimplementing those equations, we use the Julia package <a href="https://github.com/JuliaHealth/KomaMRI.jl">KomaMRI.jl</a> to run the simulation and obtain <span class="math inline">\(\mathrm{\mathbf{A}}(\mathbf{x})\)</span>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">KomaMRICore</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co"># A(x) - our forward model</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">forward</span>(x, params)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    seq_aux <span class="op">=</span> <span class="fu">copy</span>(params.seq)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    seq_aux.RF[<span class="fl">1</span>].A <span class="op">.=</span> x <span class="co"># Update RF pulse</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    mag <span class="op">=</span> <span class="fu">simulate</span>(params.obj, seq_aux, params.sys; params.sim_params)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mag</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># ||A(x) - b||2^2 - our loss function</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">loss</span>(x, params)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    mag <span class="op">=</span> <span class="fu">forward</span>(x, params)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">sum</span>(abs2, mag.xy <span class="op">.-</span> params.target_profile) <span class="op">/</span> <span class="fu">length</span>(mag.xy)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Then, to optimize this loss function we need to calculate a gradient using <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a> or <a href="https://github.com/EnzymeAD/Enzyme.jl">Enzyme.jl</a>. For example, using FiniteDiff.jl it would look like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">calc_grad!</span>(‚àáloss, x, params) <span class="op">=</span> FiniteDiff.<span class="fu">finite_difference_gradient!</span>(‚àáloss, x <span class="op">-&gt;</span> <span class="fu">loss</span>(x, params), x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally, we can use a method like Malitsky-Mishchenko adaptive <strong>gradient descent</strong> to solve our inverse problem.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/figure_6_optimization.gif" class="img-fluid figure-img"></p>
<figcaption>Fig. 6a: Design of a complex 2D RF excitation minimizing mean squared error. (A) The target magnetization profile matches a logo. The simulated magnetization (B) used during RF pulse optimization closely matched the measured magnetization (D) obtained by executing the optimized RF pulse (C) with Pulseq on a real MRI scanner.</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/PXL_20251023_170128686.jpg" class="img-fluid figure-img"></p>
<figcaption>Fig. 6b: I was so excited after making this work in a real scanner, that I took a picture to celebrate. Inside the MRI machine you can see an spherical water bottle that I used for all these experiments.</figcaption>
</figure>
</div>
<p>The previous optimization (Fig. 6) took around 5 hours, as it run on the CPU using <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>. We did the same using <strong>GPU kernels</strong> using <a href="https://github.com/JuliaGPU/KernelAbstractions.jl">KernelAbstractions.jl</a> and <a href="https://github.com/EnzymeAD/Enzyme.jl">Enzyme.jl</a> using reverse-mode AD and we <strong>were able to optimize this in under 5 seconds</strong>.</p>
<p>And now the star of the show, the <strong>Julia logo</strong>, in all its spins‚Äô glory:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/rf_2dexcitation_logo.gif" class="img-fluid figure-img"></p>
<figcaption>Fig. 7: Optimized RF pulse imprints the Julia logo in the spins of a simulated water bottle.</figcaption>
</figure>
</div>
<p>These optimized pulses (and others) were validated on a <strong>real MRI scanner</strong>, and the acquired images closely matched the simulations from <a href="https://github.com/JuliaHealth/KomaMRI.jl">KomaMRI.jl</a>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/figure_4_more_logos.png" class="img-fluid figure-img"></p>
<figcaption>Fig. 8: (A-C) Target 2D RF excitation patterns and (D-F) reconstructed 2D magnetization patterns from the optimized RF pulses obtained in a spherical phantom. The results demonstrate good correspondence between targets (A-C) and reconstructed profiles (D-F). The red dashed line shows the spherical phantom‚Äôs boundary. (G-I) Shows the optimized RF pulses that were used for the acquisitions.</figcaption>
</figure>
</div>
</section>
<section id="conclusions" class="level1">
<h1>Conclusions</h1>
<p>Using Julia and GPU‚Äëaccelerated simulations, radio‚Äëfrequency (RF) pulses were designed in under five seconds. This made it possible to ‚Äúdraw‚Äù the Julia logo in a water‚Äëbottle phantom using a real MRI scanner. More than a cool technical demostration, sub‚Äëminute design times make patient‚Äëspecific pulse tailoring practical: pulses could be optimized for a person‚Äôs anatomy or implants to improve image quality and reduce artifacts.</p>
<p>This work was submitted as an abstract to the upcoming International Society for Magnetic Resonance in Medicine (ISMRM) conference.</p>
</section>
<section id="acknowledgemnts" class="level1">
<h1>Acknowledgemnts</h1>
<p>This work would not have been possible without many Julia packages: CUDA.jl, KernelAbstractions.jl, Enzyme.jl, FiniteDiff.jl, Makie.jl, KomaMRI.jl, and others. Thanks to the Julia community for being awesome üòä. Special thanks to Kareem Fareed, who implemented the Enzyme-based version of this work, to John Pauly for insightful discussions, and to Daniel Ennis for his supervision and continuous support.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/cncastillo\.github\.io\/BlochHole");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>